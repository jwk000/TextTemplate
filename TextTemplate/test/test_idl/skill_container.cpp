//this file is generated by codedump at 2023/11/21 16:30:49 do NOT edit it !

#include "skill_container.h"


bool skill_containerParser::Initialize(const char* file)
{
	Init(this);
	return Register(file, &skill_containerParser::LoadConfig);
}

bool skill_containerParser::LoadConfig(nlohmann::json& root, bool init)
{
    try
    {
        return ParseSkillContainer(root, m_config);
    }
    catch(nlohmann::detail::exception ex)
    {
     	LogError("skill_containerParser::LoadConfig error: ", ex.what());
		lightAssert(false && "skill_containerParser::LoadConfig error ");
		return false;   
    }
}

bool skill_containerParser::ParseSkillContainer(nlohmann::json& root, SkillContainer& info)
{
    {
        auto& v_dict = root["mapDesignData"];
        for(auto it=v_dict.begin(); it!=v_dict.end(); ++it)
        {
            SkillData element;
            if(!ParseSkillData(*it, element))
            {
                return false;
            }
            info.mapDesignData.emplace(element., element);
        }
    }

    return true;
}

bool skill_containerParser::ParseSkillData(nlohmann::json& root, SkillData& info)
{
    if(!root["id"].is_null())
    {
        info.id = root["id"].get<std::string>();
    }
    if(!root["name"].is_null())
    {
        info.name = root["name"].get<std::string>();
    }
    if(!root["desc"].is_null())
    {
        info.desc = root["desc"].get<std::string>();
    }
    if(!root["descSpecial"].is_null())
    {
        info.descSpecial = root["descSpecial"].get<std::string>();
    }
    if(!root["icon"].is_null())
    {
        info.icon = root["icon"].get<std::string>();
    }
    if(!root["memorySlot"].is_null())
    {
        info.memorySlot = root["memorySlot"].get<int>();
    }
    if(!root["actionPt"].is_null())
    {
        info.actionPt = root["actionPt"].get<int>();
    }
    if(!root["cd"].is_null())
    {
        info.cd = root["cd"].get<float>();
    }
    if(!root["resistedBy"].is_null())
    {
        info.resistedBy = root["resistedBy"].get<std::string>();
    }
    if(!root["range"].is_null())
    {
        info.range = root["range"].get<float>();
    }
    if(!root["category"].is_null())
    {
        info.category = root["category"].get<std::string>();
    }
    {
        auto& v_list = root["effList"];

        for(auto it=v_list.begin(); it!=v_list.end(); ++it)
        {
            SkillEffectInfo element;
            if(!ParseSkillEffectInfo(*it, element))
            {
                return false;
            }
            info.effList.push_back(element);
            
        }
    }

    return true;
}

bool skill_containerParser::ParseSkillEffectInfo(nlohmann::json& root, SkillEffectInfo& info)
{
    if(!root["effId"].is_null())
    {
        info.effId = root["effId"].get<std::string>();
    }
    if(!root["effType"].is_null())
    {
        info.effType = root["effType"].get<std::string>();
    }
    if(!root["locateType"].is_null())
    {
        info.locateType = root["locateType"].get<std::string>();
    }
    if(!root["targetPosOffsetX"].is_null())
    {
        info.targetPosOffsetX = root["targetPosOffsetX"].get<float>();
    }
    if(!root["targetPosOffsetY"].is_null())
    {
        info.targetPosOffsetY = root["targetPosOffsetY"].get<float>();
    }
    if(!root["targetPosOffsetZ"].is_null())
    {
        info.targetPosOffsetZ = root["targetPosOffsetZ"].get<float>();
    }

    return true;
}



